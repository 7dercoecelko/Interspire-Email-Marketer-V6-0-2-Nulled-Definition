{
  "rules": {

    // by default rules are false
    // nested rules can not change rules above
    ".read": false,
    ".write": false,

    "users": {
      // no one can read user list,

      "$userID": {
        // only auth user can read themselves
        ".read": "$userID === auth.uid",

        // if no prev data and authed (create) OR you are the user
        ".write": "(!data.exists() && auth != null) || $userID === auth.uid",
        ".validate": "newData.hasChildren(['provider', 'created'])"
      }
    },

    "userSettings": {
      "$settingID": {
        // only auth user can read themselves
        ".read": "auth != null && (data.child('user').val() === auth.uid)",

        // can write if it is you, or creating a new one
        ".write": "auth != null && !data.exists() || (data.child('user').val() === auth.uid)",
        ".validate": "newData.child('user').val() === auth.uid"
      }
    },

    "channels": {
      ".read": true,

      // this allows us to query by slug (normally it's only by ID)
      ".indexOn": ["slug", "tracks", "isFeatured"],

      "$channelID": {
        // if your user has the channel OR no previous data and authenticated (create)
        ".write": "root.child('users').child(auth.uid).child('channels').child($channelID).exists() || auth != null && !data.exists()"
      }
    },

    "channelPublics": {
      ".read": true,
      ".write": true, // true until we figure out how to make sure only you can delete?

      "$channelPublicID": {
        //".write": "!newData.exists() && || auth != null"
        // (1) channel has to stay the same. (2) if new, you have to own the channel you're adding a channelPublic for
        //".validate": "!data.exists() && root.child('users').child(auth.uid).child('channels').child(newData.child('channel').val()).exists()"
      }
    },

    "tracks": {
      ".read": true,
      ".indexOn": ["channel", "title"],

      "$trackID": {
        // you have to be authed
        ".write": "auth != null",
        // and you have to own the track's channel
        ".validate": "root.child('users').child(auth.uid).child('channels').child(newData.child('channel').val()).exists()"
      }
    },

    "images": {
      ".read": true,
      "$imageID": {
        // you have to be authed
        ".write": "auth != null",
        // and you have to own the track's channel
        ".validate": "root.child('users').child(auth.uid).child('channels').child(newData.child('channel').val()).exists()"
      }
    }
  }
}
