{
  "rules": {

    // by default rules are false
    // nested rules can not change rules above
    ".read": false,
    ".write": false,

    "users": {
      // no one can read user list,

      "$userID": {
        // only auth user can read themselves
        ".read": "$userID === auth.uid",

        // if no prev data and authed (create) OR you are the user
        ".write": "(!data.exists() && auth != null) || $userID === auth.uid",
        ".validate": "newData.hasChildren(['provider', 'created'])"
      }
    },

    "userSettings": {
      "$settingID": {
        // only auth user can read themselves
        ".read": "auth != null && (data.child('user').val() === auth.uid)",

        // can write if it is you, or creating a new one
        ".write": "auth != null && !data.exists() || (data.child('user').val() === auth.uid)",
        ".validate": "newData.child('user').val() === auth.uid"
      }
    },

    "channels": {
      ".read": true,

      // this allows us to query by slug (normally it's only by ID)
      ".indexOn": ["slug", "tracks", "isFeatured"],

      "$channelID": {
        // if your user has the channel OR no previous data and authenticated (create)
        ".write": "root.child('users').child(auth.uid).child('channels').child($channelID).exists() || auth != null && !data.exists()"
      }
    },

    "channelPublics": {
      ".read": true,

      "$channelPublicID": {

        // delete is allowed if you own the channel relationship OR create/update is allowed if you're authed
        // this means you can change channel â€” but we can't validate and check for equality because that won't validate
        // on create/delete
        ".write": "!newData.exists() && root.child('users').child(auth.uid).child('channels').child(data.child('channel').val()).exists()
                 || newData.exists() && auth != null"
        //".validate": "data.child('channel').val() === newData.child('channel').val()"
      }
    },

    "tracks": {
      ".read": true,
      ".indexOn": ["channel", "title"],

      "$trackID": {
        // you have to be authed
        ".write": "auth != null",
        // and you have to own the track's channel
        ".validate": "root.child('users').child(auth.uid).child('channels').child(newData.child('channel').val()).exists()"
      }
    },

    "images": {
      ".read": true,
      "$imageID": {
        // you have to be authed
        ".write": "auth != null",
        // and you have to own the track's channel
        ".validate": "root.child('users').child(auth.uid).child('channels').child(newData.child('channel').val()).exists()"
      }
    }
  }
}
